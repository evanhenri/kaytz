---
- name: Install apt dependencies
  apt:
    name: "{{ item }}"
    install_recommends: no
  with_items:
    - lxc
    - lxc-templates
  become: true

- name: Set /var/lib/lxc directory permissions
  file:
    path: "/var/lib/lxc"
    mode: 0755
    recurse: yes
    state: directory
  become: true

- name: Assign unpriveleged UID range
  command: usermod --add-subuid 100000-165536 {{ ansible_user }}
  become: true

- name: Assign unprivileged GID range
  command: usermod --add-subgid 100000-165536 {{ ansible_user }}
  become: true

- name: Copy /etc/lxc/default.conf
  template:
    src: "{{ role_path }}/files/default.conf"
    dest: /etc/lxc/default.conf
    mode: 0644
  become: true

- name: Copy /etc/default/lxc-net
  template:
    src: "{{ role_path }}/files/lxc-net"
    dest: /etc/default/lxc-net
    mode: 0644
  become: true

- name: Detect running nodes
  command: lxc-ls --running --line
  register: lxc_running
  become: true
  changed_when: lxc_running.stdout_lines | length > 0

- name: Define nx_dns_nodes
  set_fact:
    nx_dns_nodes: []

- name: Redefine nx_dns_nodes as nodes without cooresponding dns A records
  set_fact:
    nx_dns_nodes: |
      {{ nx_dns_nodes }} + {{
        [] if lookup('dig', item + './A', '@' + phys_intf_ip ) | ipaddr else [item]
      }}
  with_items: "{{ lxc_running.stdout_lines }}"
  changed_when: nx_dns_nodes | length > 0

# fixme: this is a hacky workaround.
# not sure why DHCID records remain when the corresponding A record is no longer present
- name: Delete lingering DHCID dns records
  shell: docker-compose exec -T db psql -c "DELETE FROM records WHERE type='DHCID' AND name NOT IN (SELECT name FROM records WHERE type='A');"
  args:
    chdir: "{{ home }}/pdns"
  register: psql_retval
  changed_when: "'DELETE 0' not in psql_retval.stdout_lines[0]"

- name: Stop invalid running nodes
  command: lxc-stop --name={{ item }}
  with_items: "{{ nx_dns_nodes }}"
  become: true
  changed_when: nx_dns_nodes | length > 0

- name: Detect stopped nodes
  command: lxc-ls --stopped --line
  register: lxc_stopped
  become: true
  changed_when: lxc_stopped.stdout_lines | length > 0

- name: Destroy stopped nodes
  command: lxc-destroy --name={{ item }}
  with_items: "{{ lxc_stopped.stdout_lines }}"
  become: true
  changed_when: lxc_stopped.stdout_lines | length > 0

- name: Detect running nodes
  command: lxc-ls --running --line
  register: lxc_running
  become: true
  changed_when: lxc_running.stdout_lines | length > 0

- name: Create nodes that are not already running
  command: |
    lxc-create \
      --template=download \
      --name={{ item.value.fqdn }} \
      -- \
      --dist={{ item.value.dist }} \
      --arch={{ item.value.arch }} \
      --release={{ item.value.release }}
  with_dict: "{{ nodes }}"
  when: item.value.fqdn not in lxc_running.stdout_lines
  become: true

- name: Generate node config files
  copy:
    dest: "/var/lib/lxc/{{ item.value.fqdn }}/config"
    mode: 0644
    content: |
      lxc.include = /usr/share/lxc/config/ubuntu.common.conf
      lxc.include = /usr/share/lxc/config/ubuntu.userns.conf

      lxc.rootfs = /var/lib/lxc/{{ item.value.fqdn }}/rootfs
      lxc.rootfs.backend = dir
      lxc.utsname = {{ item.value.fqdn }}
      lxc.arch = amd64

      lxc.include = /etc/lxc/default.conf
      lxc.network.name = eth0
      lxc.network.veth.pair = {{ item.value.name }}

      # Default to empty ipv4 address as the container will get assigned an ip via dhcp from the kia docker container
      lxc.network.ipv4 = 0.0.0.0/{{ k8s_prefix }} {{ k8s_broadcast }}
      lxc.network.ipv4.gateway = auto
      lxc.start.auto = 1
  with_dict: "{{ nodes }}"
  become: true

- name: Start nodes
  command: lxc-start --name={{ item.value.fqdn }} --daemon
  with_dict: "{{ nodes }}"
  when: item.value.fqdn not in lxc_running.stdout_lines
  become: true

- name: Pause n seconds for nodes to get ip address reservations
  pause:
    seconds: "{{ lxc_running.stdout_lines | difference(nodes) | length }}"

- name: Update master_nodes with ip addresses
  set_fact:
    master_nodes: |
      {{ master_nodes | combine({
          item.key: {
            'ansible_host': lookup('dig', item.value.fqdn + '.', '@' + phys_intf_ip )
          }
        }, recursive=True)
      }}
  with_dict: "{{ master_nodes }}"

- name: Update worker_nodes with ip addresses
  set_fact:
    worker_nodes: |
      {{ worker_nodes | combine({
          item.key: {
            'ansible_host': lookup('dig', item.value.fqdn + '.', '@' + phys_intf_ip )
          }
        }, recursive=True)
      }}
  with_dict: "{{ worker_nodes }}"

- name: Redefine nodes to include the updated worker and master node configs
  set_fact:
    nodes: "{{ master_nodes | combine(worker_nodes, recursive=True) }}"

- name: Check validity of node ip addresses
  assert:
    that: item.value.ansible_host | ipaddr
  with_dict: "{{ nodes }}"

- name: Detect node users
  shell: "lxc-attach -n {{ item.value.fqdn }} -- bash -c 'cut -d: -f1 /etc/shadow'"
  register: node_users_output
  with_dict: "{{ nodes }}"
  become: true

- name: Define node_users
  set_fact:
    node_users: |
      {{ node_users | default({}) | combine({
          result.item.value.fqdn: result.stdout_lines | unique
        })
      }}
  with_items: "{{ node_users_output.results }}"
  loop_control:
    loop_var: result

- name: Create sudo user for nodes
  shell: |
    lxc-attach -n {{ item.value.fqdn }} -- \
      useradd --create-home --groups sudo --shell /bin/bash {{ item.value.ansible_user }};
  with_dict: "{{ nodes }}"
  when: item.value.ansible_user not in node_users[item.value.fqdn]
  become: true

- name: Create ~/.ssh directory for sudo user in each node
  file:
    path: "{{ item.value.home }}/.ssh"
    mode: 0700
    owner: "{{ item.value.uid }}"
    group: "{{ item.value.gid }}"
    state: directory
    recurse: yes
  with_dict: "{{ nodes }}"
  become: true

- name: Disable password verification for users in sudo group
  replace:
    path: "/var/lib/lxc/{{ item.value.fqdn }}/rootfs/etc/sudoers"
    regexp: '^(%sudo\s+ALL=\(ALL:ALL\))\s(ALL)$'
    replace: '\1 NOPASSWD: \2'
  with_dict: "{{ nodes }}"
  become: true

- name: Generate lxc_rsa ssh key for bastion host to access nodes
  user:
    name: "{{ ansible_user }}"
    generate_ssh_key: yes
    ssh_key_bits: 4096
    ssh_key_file: "{{ home }}/.ssh/lxc_rsa"
    ssh_key_type: rsa
  no_log: True

- name: Create bastion host ssh config
  copy:
    dest: "{{ home }}/.ssh/config"
    mode: 0600
    content: |
      Host {{ k8s_node_ssh_rgx }}
          IdentityFile {{ home }}/.ssh/lxc_rsa
          User {{ lxc_user }}
          StrictHostKeyChecking no
          # UserKnownHostsFile=/dev/null

- name: Create ansible hosts for dynamically created 'nodes' inventory group
  add_host:
    groups: nodes
    name: "{{ item.value.fqdn }}"

    # Vars required for ssh proxying through bastion host into nodes
    ansible_host: "{{ item.value.ansible_host }}"
    ansible_ssh_common_args: >
      -o ProxyCommand="ssh -W %h:%p {{ ansible_user }}@{{ inventory_hostname }}"
      -o HostName={{ item.value.fqdn }}
      -o UserKnownHostsFile=/dev/null
      -o StrictHostKeyChecking=no
    ansible_user: "{{ lxc_user }}"
  with_dict: "{{ nodes }}"

- name: Run bootstrap commands inside nodes
  shell: |
    lxc-attach -n {{ item.value.fqdn }} -- bash -c "\
      apt-get update \
      && apt-get upgrade -y \
      && apt-get install -y --no-install-recommends \
        libsasl2-dev \
        libssl-dev \
        openssh-server \
        python-minimal \
        python-pkg-resources \
        python-pip \
        python-setuptools"
  with_dict: "{{ nodes }}"
  become: true

- name: Copy bastion host ssh public key to node authorized_keys files
  copy:
    src: "{{ home }}/.ssh/lxc_rsa.pub"
    dest: "{{ item.value.home }}/.ssh/authorized_keys"
    mode: 0600
    owner: "{{ item.value.uid }}"
    group: "{{ item.value.gid }}"
    remote_src: True
  with_dict: "{{ nodes }}"
  become: true

- name: Define id_rsa_pub_path as local user's ssh public key path
  set_fact:
    id_rsa_pub_path: "{{ lookup('ini', 'private_key_file section=defaults file=ansible.cfg') }}.pub"

- name: Define id_rsa_pub_content as local user's ssh public key string
  set_fact:
    id_rsa_pub_content: "{{ lookup('file', id_rsa_pub_path) }}"

# Cannot use authorized_key module because the value for the required param 'user'
# would be set to {{ lxc_user }}, causing it to fail as {{ lxc_user }} does not exist
# in /etc/shadow of bastion host
- name: Add local user's ssh public key to authorized_keys file of nodes
  lineinfile:
    line: "{{ id_rsa_pub_content }}"
    dest: "{{ item.value.home }}/.ssh/authorized_keys"
    regexp: "^{{ id_rsa_pub_content }}$"
  with_dict: "{{ nodes }}"
  become: true
